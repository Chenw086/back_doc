---
title: redis - 事务
---

# 事务

**举例：** 银行转账，A 账户给 B 账户转账一个亿（T1），买一块地盖房子。在这个过程中有几个问题值得思考：

- 如何同时保证上述交易中，A 账户总金额减少一个亿，B 账户总金额增加一个亿？
- A 账户如果同时在和 C 账户交易（T2），如何让这两笔钱互不影响？
- 如果交易完成时数据库突然崩溃，如何保证交易数据数据成功保存在数据库中？
- 如何在支持大量交易的同时，保证数据数据的合法性？

要保证交易正常可靠的进行，数据库就得解决上面的四个问题，这也就是事务

**四大特性**

1. 原子性：事务要么全部完成，要么全部取消。如果事务崩溃，状态回到事务之前（事务回滚）
   > 确保不管交易过程中发生什么意外状况（服务器崩溃、网络终端等），不能出现 A 账户少了一个亿，但是 B 账户没有到账（数据不一致）
   >
   > A 和 B 账户的金额变动要么同时成功，要么同时失败（保持现状）
2. 隔离性：如果两个事务 T1 和 T2 同时运行，事务 T1 和 T2 最终的结果是相同的，不管 T1 和 T2 谁先结束
   > 如果 A 转账一亿给 B（T1），同时 C 又在转账 3 亿给 A（T2），不管 T1 和 T2 谁先执行完毕，最终结果必须是 A 账户增加 2 亿，而不是 3 亿，B 增加 1 亿，C 减少 3 亿
3. 持久性：一旦事务提交，不管发生什么（崩溃或者出错），数据要保存在数据库中
   > 确保如果 T1 刚刚提交，数据库就发生崩溃，T1 执行的结果依然会保持在数据库中
4. 一致性：只有合法的数据（依照关系约束和函数约束），才能写入数据库
   > 确保钱不会在系统内凭空产生或消失，依赖源自行和隔离性

原子性、隔离性、一致性的根本问题，是不同的事务同时对同一份数据（A 账户）进行写操作（修改、删除、新增），如果事务中都只是读数据的话，那么它们可以随意地同时进行，反正读到的数据是一样的

如果几个互不知晓的事务在同时修改同一份数据，那么很容易出现后完成的事务覆盖了前面的事务的结果，导致不一致。事务在最终提交之前都有可能会回滚，撤销所有修改：

- 如果 T1 事务修改了 A 账户的数据
- 这时 T2 事务读到了更新后 A 账户数据，并进行下一步操作
- 但此时 T1 事务却会滚了，撤销了对 A 账户的修改
- 那么 T2 读取到的 A 账户数据就是非法的，这会导致数据不一致

## 处理事务

redis 中提供了以下三个命令来处理事务

::: code-group

```bash [语法]
# 标记一个事务块的开始
# 事务块内的多条命了会按照先后顺序被放进一个队列当中，最后 EXEC 命令执行
MULTI

# 执行所有事务块的命令
EXEC

# 取消事务，放弃执行事务块内所有命令
DISCARD
```

```sql [示例]
127.0.0.1:6379> SET jack 10
OK
127.0.0.1:6379> SET rose 20
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379(TX)> DECRBY jack 5
QUEUED
127.0.0.1:6379(TX)> INCRBY rose 5
QUEUED
127.0.0.1:6379(TX)> EXEC
1) (integer) 5
2) (integer) 25
127.0.0.1:6379> INCRBY rose 5
(integer) 30
```

:::

redis 保证了一个事务中的所有命令要么都执行，要么都不执行

如果在发送 EXEC 命令前客户端掉线了，则 redis 会清空事务队列，事务中的所有命令都不会执行

而一旦客户端发送了 EXEC 命令，所有的命令都会被执行，即使此后客户端掉线也没关系，因为 redis 中已经记录了所有要执行的命令

除此之外，redis 的事务还能保证一个事务内的命令依次执行而不被其它命令插入

## 错误处理

什么原因导致执行出错：

1. 语法错误。语法错误指命令不存在或命令参数的个数不对。如：

```bash
MULTI

# 正确命令
SET key value

# 错误命令
SET key

ERRORCOMMAND key

EXEC
```

跟在 MULTI 命令后执行了三个命令：

- 一个正确的命令，成功的加入了事务队列
- 其余两个命令都有语法错误

而只要有一个命令有语法错误，执行 EXEC 命令后 redis 就会直接返回错误，连语法正确的命令也不会执行

2. 运行错误

指在命令执行时出现的错误，比如使用散列类型的命令操作集合类型的键，这中错误在实际执行之前 redis 是无法发现的，所以在事务里这样的命令是会被 redis 接受并执行的

如果事务里一条命令出现了运行错误，事务里其它的命令依然会继续执行

```bash
127.0.0.1:6379> MULTI
OK

127.0.0.1:6379(TX)> SET key 1
QUEUED

127.0.0.1:6379(TX)> SADD key 2
QUEUED

127.0.0.1:6379(TX)> SET key 3
QUEUED

127.0.0.1:6379(TX)> EXEC
1) OK
2) (error) WRONGTYPE Operation against a key holding the wrong kind of value
3) OK

127.0.0.1:6379>  GET KEY
(nil)

127.0.0.1:6379>  GET key
"3"
```

虽然 SADD key 2 出现了错误，但是 SET key 3 依然被执行了

::: danger
redis 事务没有关系性数据库事务提供的会滚（rollback）功能

为此开发者必须在事务执行出错后自己收拾烂摊子（将数据库复原回事务执行前的状态）
:::

不过由于 redis 不支持回滚功能，也使得 redis 在事务上可以保持简洁和快速

此外回顾刚才提到的回道之事务执行失败的两种错误，其中语法错误完全可以在开发时找出并解决，另外如果能够很好的规划数据库的使用，是不会出现如命令与数据类型不匹配这样的运行时错误的

## watch

假设银行卡有 100 元，此时去商店购物，同时自己老婆在别处直接花了 100,此时不知情的我还在买东西，结算的时候发现余额不足

::: code-group

```bash [自己]
127.0.0.1:6379> SET balance 100
OK

127.0.0.1:6379> MULTI
OK
127.0.0.1:6379(TX)> DECRBY balance 10
QUEUED
127.0.0.1:6379(TX)> DECRBY balance 20
QUEUED
127.0.0.1:6379(TX)> EXEC
1) (integer) -10
2) (integer) -30
127.0.0.1:6379>
```

```bash [老婆]
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379(TX)> DECRBY balance 100
QUEUED
127.0.0.1:6379(TX)> EXEC
1) (integer) 0
127.0.0.1:6379> GET balance
"0"
```

:::

针对以上这个场景，可以使用 redis 事务中提供的 watch 功能来解决这个问题

watch 定义：监视一个（或多个 ）key，如果在事务执行之前这个 key 被其它命令所改动，那么事务将被打断

::: code-group

```bash [语法]
WATCH key [key ...]

UNWATCH
```

```bash [示例：自己]
127.0.0.1:6379> SET balance 100
OK

127.0.0.1:6379> WATCH balance
OK

127.0.0.1:6379> MULTI
OK

127.0.0.1:6379(TX)> DECRBY balance 10
QUEUED

127.0.0.1:6379(TX)> DECRBY balance 20
QUEUED

# 在执行之前老婆结算了

# 返回 nill 示意事务提交失败
127.0.0.1:6379(TX)> EXEC
(nil)

# balance 没有进一步减少
127.0.0.1:6379> GET balance
"0"
```

```bash [示例：老婆]
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379(TX)> DECRBY balance 100
QUEUED
127.0.0.1:6379(TX)> EXEC
1) (integer) 0
```

:::

如果在执行 watch 命令之后，exec 命令或 discard 命令被执行了的话，那么会自动取消 watch

如果手动停止 watch 则可以使用 unwatch 命令，它会取消 watch 命令对所有 key 的监视
